# Java实现简单多线程下载器
最近在学习java并发编程的内容，刚好课内linux课程需要完成一个课设，所以用java做一个简单的多线程下载器，有参考网上的设计思路，但代码都是自己码，也加入了一些改进。为了模拟远程连接服务器并将项目发布到服务器上的过程，学习了如何在window上使用xshell连接虚拟机中的linux，温习了一下maven打jar包，log4j日志框架等内容。

### 设计和实现步骤

- **判断服务器是否支持断点续传**

  首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。

  HTTP 请求头中有一个 `Range` 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 `Range:bytes=10-20`。

  相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 `Range` 字段的请求，会返回 206 状态码。

  我们用 Curl 来测试一下：

  ```
  curl -I --header "Range: bytes=0-" http://mirrors.163.com/debian/ls-lR.gz
  ```

  得到的响应：

  ```
  HTTP/1.1 206 Partial Content
  Server: nginx
  Date: Wed, 25 Apr 2018 02:57:56 GMT
  Content-Type: application/octet-stream
  Content-Length: 15316619
  Connection: keep-alive
  Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT
  ETag: "5addeff4-e9b68b"
  Content-Range: bytes 0-15316618/15316619
  ```

  我们设置 `Range: bytes=0-` ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。

  如果服务器支持断点续传，那么我们采用多线程进行下载，如果不支持断点续传，就采用单线程下载。

- **文件分段**

  我们得到了文件的大小 fileSize，将其分为 N 段，则每一段的大小为 `fileSize / N`，由于文件通常不会正好被分为 N 段，因此最后一段就等于剩余的部分的大小。

  我们用一个数组 downloadRange 来存放每一段的起始位置，例如一个 10 B 的文件，起止范围是 0~9，如果分为 3 段下载，那么 `downloadRange = {0, 3, 6, 10}`，对每段来说是左闭右开区间。

  解释：对于第 i 段（i 从 0 开始）来说，从 `downloadRange[i]` 开始下载，在 `downloadRange[i + 1] - 1` 处停止。同理，对第 i + 1 段来说，从 `downloadRange[i + 1]` 开始，在 `downloadRange[i + 2] - 1` 处停止。所以上述的例子第一段下载的范围是[0-2]，第二段下载的内容是[3-5]。

- **创建下载线程**

  我们为每一段创建一个下载线程进行下载，每一段都存放在一个单独的临时文件中。

  下载线程需要做的事情可以总结如下：

  - 设置请求头的 `Range` 字段来指定请求范围
  - 设置超时时间
  - 连接 HTTP 服务器
  - 创建临时文件（第一次下载该段）
  - 读取服务器返回的数据，写入到临时文件，直到读取的字节数等于该段的大小
  - 关闭临时文件

  上面是顺利下载的流程，我们还需要在出现下列问题时进行重试：

  - 如果连接时间或读取时间超时
  - 临时文件读写出错

- **创建监视线程**

  我们创建一个守护线程，负责监视文件的下载进度、下载速度、当前活跃线程数，在各线程下载结束后，通知主线程做下一步处理。

- **处理临时文件**

  当主线程收到通知，所有部分都下载完成时，就需要对临时文件进行处理。对一个或多个临时文件进行合并。这里可以选择清理临时文件，这次的实现采用保留临时文件。

- **注意&优化**

  - 为了使多线程下载速度比单线程速度更快，需要一个条件是下载被限速，正常情况下应该是服务器端实现限速，但是这里的服务端是网易的开源镜像栈，我们无法控制，所以这里采用的策略让下载线程在下载的过程sleep某段时间再接着下载。

  - 在测试的过程中，当出现Connection reset的异常时，根据下载失败会重新下载的策略，会开始重新下载，但是还没真正下载完全时，便提示下载成功，初步判断的原因是，在判断某一段是否下载成功时，是根据下载量是否到达endByte(也就是上面downloadRange[i+1] - 1)，所以当重新下载时，本应该从头beginByte开始计算，但其实代码中beginByte这时候的值是上次下载所到达的值。这就造成明明没下载完全，却提示下载成功，这里需要改进。

    ![连接重置后下载不完整](C:\Users\asus\Desktop\连接重置后下载不完整.jpg)



### 加入maven模块和日志模块

为了方便管理项目，加入maven管理模块；为了在服务器上查看运行过程，加入日志模块；为了方便修改下载参数（线程数，路径等等），加入配置文件，这里采用properties格式的配置文件。

- **maven模块**

  因为一开始创建项目的时候没有考虑到要部署到服务器上，所以就创建了普通java项目，这时如果要加入maven模块，在IDEA中的操作方式是**右击项目—>add Framework Support—>maven**。然后在pom文件中加入jdk版本信息，log4j的依赖信息和打包插件。（具体看代码）

- **log4j模块**

  加入log4j.properties配置文件，这里因为要体现执行过程，所以定义三个输出位置（控制台，INFO级别和ERROR级别），具体配置和解释看代码和下面的参考网站。

- **config.properties**

  定义了下载地址url，linux下的存放路径，window下的存放路径，下载线程数，下载线程睡眠时间等，方便在linux下运行的时候便于修改参数。



**参考博文：** 在上面的部署过程中，出现了许多问题，但是下面几篇博文是对我来说最有用的。

- https://juejin.im/entry/5ae05aa6f265da0ba062d5b6?utm_source=gold_browser_extension#comment
- https://www.jianshu.com/p/c6c543e4975e
- https://blog.csdn.net/sinat_18474835/article/details/82986400
- https://blog.csdn.net/wqc19920906/article/details/79257402